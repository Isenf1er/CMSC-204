import java.util.ArrayList;
import java.util.Stack;

public class NotationStack<T> implements QueueInterface<T> {
	private int cap;
	private ArrayList<T> stack;
	
	NotationStack(){
		stack = new ArrayList<>();
		cap = 10;
	}
	
	NotationStack(int cap){
		stack = new ArrayList<>(cap);
	}
	
	public boolean isFull() {
		if(stack.size() == cap) {
			return true;
		} else {
			return false;
		}
	}
	
	public boolean isEmpty() {
		if(stack.isEmpty()) {
			return true;
		} else {
			return false;
		}
	}
	
	public int size() {
		return stack.size();
	}
	
	public boolean push(T item) throws StackOverflowException{
		if(stack.size() == cap) {
			throw new StackOverflowException();
		} else {
			stack.add(item);
			return true;
		}
	}
	
	public String toString() {
		String s = " ";
		for(T item: stack) {
			s += item.toString();
		}
		return s;
	}
	
	public T pop() throws StackUnderflowException{
		if(stack.size() == 0) {
			throw new StackUnderflowException();
		} else {
			T first = stack.get(stack.size() - 1);
			return first;
		}
	}
	
	public T first() throws StackUnderflowException{
		if(stack.size() == 0) {
			throw new StackUnderflowException();
		} else {
			return stack.get(stack.size() - 1);
		}
	}
	
	public T dequeue() throws StackUnderflowException{
		if(isEmpty()) {
			throw new StackUnderflowException();
		} else {
		return stack.size();
		}
	}
	
	public boolean enqueue(T e) throws StackOverflowException{
		if(stack.size() == cap) {
			throw new StackOverflowException();
		} else {
			stack.add(e);
			return true;
		}
	}
	
	public String toString(String delimiter) {
		String s = " ";
		for(T item: stack) {
			s += item.toString();
			s += delimiter;
		}
		s = s.substring(0, s.length() - 1);
		return s;
	}
	
	public void fill(ArrayList<T> list) {
		stack.clear();
		for(T item: list) {
			stack.add(item);
		}
	}
}

import static org.junit.Assert.*;

import java.util.ArrayList;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

public class NotationStackTest {
	public NotationStack<String> stringS;
	public String a="a", b="b", c="c", d="d", e="e", f="f";
	public ArrayList<String> fill = new ArrayList<String>();
	
	// STUDENT: student tests will use the doubleS
	public NotationStack<Double> doubleS;
	// STUDENT: add variables as needed for your student tests
	
	@Before
	public void setUp() throws Exception {
		stringS = new NotationStack<String>(5);
		stringS.push(a);
		stringS.push(b);
		stringS.push(c);
		
		//STUDENT: add setup for doubleS for student tests
	}

	@After
	public void tearDown() throws Exception {
		stringS = null;
		doubleS = null;
	}

	@Test
	public void testIsEmpty() throws StackUnderflowException {
		assertEquals(false,stringS.isEmpty());
		stringS.pop();
		stringS.pop();
		stringS.pop();
		assertEquals(true, stringS.isEmpty());
	}

	@Test
	public void testIsFull() throws StackOverflowException {
		assertEquals(false, stringS.isFull());
		stringS.push(d);
		stringS.push(e);
		assertEquals(true, stringS.isFull());
	}

	@Test
	public void testPop() {
		try {
			assertEquals(c, stringS.pop());
			assertEquals(b, stringS.pop());
			assertEquals(a, stringS.pop());
			//Queue is empty, next statement should cause QueueUnderFlowException
			stringS.pop();
			assertTrue("This should have caused an StackUnderflowException", false);
		}
		catch (StackUnderflowException e){
			assertTrue("This should have caused an StackUnderflowException", true);
		}
		catch (Exception e){
			assertTrue("This should have caused an StackUnderflowException", false);
		}
	}

	@Test
	public void testPopStudent() {
		//Use the doubleQ for student tests
		fail("Not yet implemented");
	}
	
	@Test
	public void testTop() throws StackOverflowException, StackUnderflowException {
		assertEquals(c, stringS.top());
		stringS.push(d);
		assertEquals(d, stringS.top());
		stringS.pop();
		stringS.pop();
		assertEquals(b, stringS.top());		
	}

	@Test
	public void testSize() throws StackUnderflowException, StackOverflowException {
		assertEquals(3, stringS.size());
		stringS.push(d);
		assertEquals(4, stringS.size());
		stringS.pop();
		stringS.pop();
		assertEquals(2, stringS.size());
	}

	@Test
	public void testPush() {
		try {
			assertEquals(3, stringS.size());
			assertEquals(true, stringS.push(d));
			assertEquals(4, stringS.size());
			assertEquals(true, stringS.push(e));
			assertEquals(5, stringS.size());
			//Queue is full, next statement should cause QueueOverFlowException
			stringS.push(f);
			assertTrue("This should have caused an StackOverflowException", false);
		}
		catch (StackOverflowException e){
			assertTrue("This should have caused an StackOverflowException", true);
		}
		catch (Exception e){
			assertTrue("This should have caused an StackOverflowException", false);
		}
	}

	@Test
	public void testPushStudent() {
		//Use the doubleQ for student tests
		fail("Not yet implemented");
	}
	
	@Test
	public void testToString() throws StackOverflowException {
		assertEquals("abc", stringS.toString());
		stringS.push(d);
		assertEquals("abcd", stringS.toString());
		stringS.push(e);
		assertEquals("abcde", stringS.toString());
	}

	@Test
	public void testToStringStudent() {
		//Use the doubleQ for student tests
		fail("Not yet implemented");
	}
	
	@Test
	public void testToStringDelimiter() throws StackOverflowException {
		assertEquals("a%b%c", stringS.toString("%"));
		stringS.push(d);
		assertEquals("a&b&c&d", stringS.toString("&"));
		stringS.push(e);
		assertEquals("a/b/c/d/e", stringS.toString("/"));
	}

	@Test
	public void testFill() throws StackUnderflowException {
		fill.add("apple");
		fill.add("banana");
		fill.add("carrot");
		//start with an empty queue
		stringS = new NotationStack<String>(5);
		//fill with an ArrayList
		stringS.fill(fill);
		assertEquals(3,stringS.size());
		assertEquals("carrot", stringS.pop());
		assertEquals("banana", stringS.pop());
		assertEquals("apple", stringS.pop());		
	}

}
import static org.junit.Assert.*;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

public class NotationTest {
	public String complexInfix = "(3+(((5*7)-(((8/2)-1)*4))*6))";
	public String complexPostfix =  "357*82/1-4*-6*+";
	public String easyInfix = "(5+4)";
	public String easyPostfix = "54+";
	public String intermediateInfix = "((3*(5+4))+2)";
	public String intermediatePostfix = "354+*2+";

	public String invalidPostfixExpression = "354+*-";
	public String invalidInfixExpression = "(3+5)*4)-2";
	
	public double evalComplexPostfix = 141.0;
	public double evalIntermediatePostfix = 29.0;
	public double evalEasyPostfix = 9.0;

	@Before	
	public void setUp() throws Exception {
	}

	@After
	public void tearDown() throws Exception {
	}

	@Test
	public void testComplexConvertInfixToPostfix() throws InvalidNotationFormatException {
		String postfixResult = Notation.convertInfixToPostfix(complexInfix);
		assertEquals(complexPostfix, postfixResult);
	}
	
	@Test
	public void testIntermediateConvertInfixToPostfix() throws InvalidNotationFormatException {
		String postfixResult = Notation.convertInfixToPostfix(intermediateInfix);
		assertEquals(intermediatePostfix, postfixResult);
	}
	
	@Test
	public void testEasyConvertInfixToPostfix() throws InvalidNotationFormatException {
		String postfixResult = Notation.convertInfixToPostfix(easyInfix);
		assertEquals(easyPostfix, postfixResult);
	}
	
	@Test
	public void testInvalidInfixExpression() {
		try{
			Notation.convertInfixToPostfix(invalidInfixExpression);
			assertTrue("This should have thrown an InvalidNotationFormatException",false);
		}
		catch (InvalidNotationFormatException e)
		{
			assertTrue("This should have thrown an InvalidNotationFormatException",true);
		}
	}
	
	@Test
	public void testComplexConvertPostfixToInfix() throws InvalidNotationFormatException {
		String infixResult = Notation.convertPostfixToInfix(complexPostfix);
		assertEquals(complexInfix, infixResult);
	}
	
	@Test
	public void testIntermediateConvertPostfixToInfix() throws InvalidNotationFormatException {
		String infixResult = Notation.convertPostfixToInfix(intermediatePostfix);
		assertEquals(intermediateInfix, infixResult);
	}
	
	@Test
	public void testEasyConvertPostfixToInfix() throws InvalidNotationFormatException {
		String infixResult = Notation.convertPostfixToInfix(easyPostfix);
		assertEquals(easyInfix, infixResult);
	}

	@Test
	public void testInvalidPostfixExpressionB() {
		try{
			Notation.convertPostfixToInfix(invalidPostfixExpression);
			assertTrue("This should have thrown an InvalidNotationFormatException",false);
		}
		catch (InvalidNotationFormatException e)
		{
			assertTrue("This should have thrown an InvalidNotationFormatException",true);
		}
	}
	
	@Test
	public void testComplexEvaluatePostfixExpression() throws InvalidNotationFormatException {
		double result = Notation.evaluatePostfixExpression(complexPostfix);
		assertEquals(evalComplexPostfix, result, .001);
	}
	
	@Test
	public void testIntermediateEvaluatePostfixExpression() throws InvalidNotationFormatException {
		double result = Notation.evaluatePostfixExpression(intermediatePostfix);
		assertEquals(evalIntermediatePostfix, result, .001);
	}
	
	@Test
	public void testEasyEvaluatePostfixExpression() throws InvalidNotationFormatException {
		double result = Notation.evaluatePostfixExpression(easyPostfix);
		assertEquals(evalEasyPostfix, result, .001);
	}
	
	@Test
	public void testInvalidPostfixExpressionA() {
		try{
			Notation.evaluatePostfixExpression(invalidPostfixExpression);
			assertTrue("This should have thrown an InvalidNotationFormatException",false);
		}
		catch (InvalidNotationFormatException e)
		{
			assertTrue("This should have thrown an InvalidNotationFormatException",true);
		}
	}
}
import java.util.ArrayList;

/** Interface for a Queue data structure
 * 
 * @author Professor Kartchner
 *
 * @param <T> data type
 */
public interface QueueInterface<T> {
	/** provide two constructors 
	 * 1. takes an int as the size of the queue
	 * 2. default constructor - uses a default as the size of the queue
	 * 
	 */

	/**
	 * Determines if Queue is empty
	 * @return true if Queue is empty, false if not
	 */
	public boolean isEmpty();

	/**
	 * Determines of the Queue is empty
	 * @return
	 */
	public boolean isFull();
	
	/**
	 * Deletes and returns the element at the front of the Queue
	 * @return the element at the front of the Queue
	 */
	public T dequeue() throws QueueUnderflowException;

	/**
	 * Number of elements in the Queue
	 * @return the number of elements in the Queue
	 */
	public int size();
	
	/**
	 * Adds an element to the end of the Queue
	 * @param e the element to add to the end of the Queue
	 * @return true if the add was successful, false if not
	 */
	public boolean enqueue(T e) throws QueueOverflowException;
	
	
	/**
	 * Returns the string representation of the elements in the Queue, 
	 * the beginning of the string is the front of the queue
	 * @return string representation of the Queue with elements
	 */
	public String toString();
	
	/**
	 * Returns the string representation of the elements in the Queue, the beginning of the string is the front of the queue
	 * Place the delimiter between all elements of the Queue
	 * @return string representation of the Queue with elements separated with the delimiter
	 */
	public String toString(String delimiter);
	
	 /**
	  * Fills the Queue with the elements of the ArrayList, First element in the ArrayList
	  * is the first element in the Queue
	  * YOU MUST MAKE A COPY OF LIST AND ADD THOSE ELEMENTS TO THE QUEUE, if you use the
	  * list reference within your Queue, you will be allowing direct access to the data of
	  * your Queue causing a possible security breech.
	  * @param list elements to be added to the Queue
	  */
	public void fill(ArrayList<T> list);
	
 

}


public class QueueOverflowException extends Exception {	
	
	public QueueOverflowException() {
		
	}
	
	public QueueOverflowException(String message){
		super(message);
	}
	
}


public class QueueUnderflowException extends Exception {

	public QueueUnderflowException() {
		
	}
	
	public QueueUnderflowException(String message) {
		super(message);
	}
	
}

import java.util.ArrayList;

/** Interface for a generic Stack data structure
 * 
 * @author Professor Kartchner
 *
 * @param <T> data type
 */
public interface StackInterface<T> {

	/**
	 * Provide two constructors
	 * 1. takes in an int as the size of the stack
	 * 2. default constructor - uses default as the size of the stack
	 */
	
	/**
	 * Determines if Stack is empty
	 * @return true if Stack is empty, false if not
	 */
	public boolean isEmpty();

	/**
	 * Determines if Stack is full
	 * @return true if Stack is full, false if not
	 */
	public boolean isFull();
	

	/**
	 * Deletes and returns the element at the top of the Stack
	 * @return the element at the top of the Stack
	 */
	public T pop() throws StackUnderflowException;
	
	/**
	 * Returns the element at the top of the Stack, does not pop it off the Stack
	 * @return the element at the top of the Stack
	 */
	public T top() throws StackUnderflowException;

	/**
	 * Number of elements in the Stack
	 * @return the number of elements in the Stack
	 */
	public int size();
	
	/**
	 * Adds an element to the top of the Stack
	 * @param e the element to add to the top of the Stack
	 * @return true if the add was successful, false if not
	 */
	public boolean push(T e) throws StackOverflowException;
	
	
	/**
	 * Returns the elements of the Stack in a string from bottom to top, the beginning 
	 * of the String is the bottom of the stack
	 * @return an string which represent the Objects in the Stack from bottom to top
	 */
	public String toString();
	
	/**
	 * Returns the string representation of the elements in the Stack, the beginning of the 
	 * string is the bottom of the stack
	 * Place the delimiter between all elements of the Stack
	 * @return string representation of the Stack from bottom to top with elements 
	 * separated with the delimiter
	 */
	public String toString(String delimiter);
	
	 /**
	  * Fills the Stack with the elements of the ArrayList, First element in the ArrayList
	  * is the first bottom element of the Stack
	  * YOU MUST MAKE A COPY OF LIST AND ADD THOSE ELEMENTS TO THE STACK, if you use the
	  * list reference within your Stack, you will be allowing direct access to the data of
	  * your Stack causing a possible security breech.
	  * @param list elements to be added to the Stack from bottom to top
	  */
	public void fill(ArrayList<T> list);
 
}


public class StackOverflowException extends Exception {

	public StackOverflowException() {
		
	}
	
	public StackOverflowException(String message) {
		super(message);
	}
	
}


public class StackUnderflowException extends Exception {

	public StackUnderflowException() {
		
	}
	
	public StackUnderflowException(String message) {
		super(message);
	}
	
}


public class InvalidNotationFormatException extends Exception {

	public InvalidNotationFormatException() {
		
	}
	
	public InvalidNotationFormatException(String message) {
		super(message);
	}
	
}

import static org.junit.Assert.*;

import java.util.ArrayList;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

public class MyQueueTest {
	public MyQueue<String> stringQ;
	public String a="a", b="b", c="c", d="d", e="e", f="f";
	public ArrayList<String> fill = new ArrayList<String>();
	
	// STUDENT: student tests will use the doubleQ
	public MyQueue<Double> doubleQ;
	// STUDENT: add variables as needed for your student tests

	@Before
	public void setUp() throws Exception {
		stringQ = new MyQueue<String>(5);
		stringQ.enqueue(a);
		stringQ.enqueue(b);
		stringQ.enqueue(c);
		
		//STUDENT: add setup for doubleQ for student tests
	}

	@After
	public void tearDown() throws Exception {
		stringQ = null;
		doubleQ = null;
	}

	@Test
	public void testIsEmpty() throws QueueUnderflowException {
		assertEquals(false,stringQ.isEmpty());
		stringQ.dequeue();
		stringQ.dequeue();
		stringQ.dequeue();
		assertEquals(true, stringQ.isEmpty());
	}

	@Test
	public void testDequeue() {
		try {
			assertEquals(a, stringQ.dequeue());
			assertEquals(b, stringQ.dequeue());
			assertEquals(c, stringQ.dequeue());
			//Queue is empty, next statement should cause QueueUnderFlowException
			stringQ.dequeue();
			assertTrue("This should have caused an QueueUnderflowException", false);
		}
		catch (QueueUnderflowException e){
			assertTrue("This should have caused an QueueUnderflowException", true);
		}
		catch (Exception e){
			assertTrue("This should have caused an QueueUnderflowException", false);
		}
	}
	
	@Test
	public void testDequeueStudent() {
		//Use the doubleQ for student tests
		fail("Not yet implemented");
	}

	@Test
	public void testSize() throws QueueUnderflowException, QueueOverflowException {
		assertEquals(3, stringQ.size());
		stringQ.enqueue(d);
		assertEquals(4, stringQ.size());
		stringQ.dequeue();
		stringQ.dequeue();
		assertEquals(2, stringQ.size());
	}

	@Test
	public void testEnqueue() {
		try {
			assertEquals(3, stringQ.size());
			assertEquals(true, stringQ.enqueue(d));
			assertEquals(4, stringQ.size());
			assertEquals(true, stringQ.enqueue(e));
			assertEquals(5, stringQ.size());
			//Queue is full, next statement should cause QueueOverFlowException
			stringQ.enqueue(f);
			assertTrue("This should have caused an QueueOverflowException", false);
		}
		catch (QueueOverflowException e){
			assertTrue("This should have caused an QueueOverflowException", true);
		}
		catch (Exception e){
			assertTrue("This should have caused an QueueOverflowException", false);
		}
	}

	@Test
	public void testEnqueueStudent() {
		//Use the doubleQ for student tests
		fail("Not yet implemented");
	}

	@Test
	public void testIsFull() throws QueueOverflowException {
		assertEquals(false, stringQ.isFull());
		stringQ.enqueue(d);
		stringQ.enqueue(e);
		assertEquals(true, stringQ.isFull());
	}

	@Test
	public void testToString() throws QueueOverflowException {
		assertEquals("abc", stringQ.toString());
		stringQ.enqueue(d);
		assertEquals("abcd", stringQ.toString());
		stringQ.enqueue(e);
		assertEquals("abcde", stringQ.toString());
	}
	
	@Test
	public void testToStringStudent() {
		//Use the doubleQ for student tests
		fail("Not yet implemented");
	}

	@Test
	public void testToStringDelimiter() throws QueueOverflowException {
		assertEquals("a%b%c", stringQ.toString("%"));
		stringQ.enqueue(d);
		assertEquals("a&b&c&d", stringQ.toString("&"));
		stringQ.enqueue(e);
		assertEquals("a/b/c/d/e", stringQ.toString("/"));
	}

	@Test
	public void testFill() throws QueueUnderflowException {
		fill.add("apple");
		fill.add("banana");
		fill.add("carrot");
		//start with an empty queue
		stringQ = new MyQueue<String>(5);
		//fill with an ArrayList
		stringQ.fill(fill);
		assertEquals(3,stringQ.size());
		assertEquals("apple", stringQ.dequeue());
		assertEquals("banana", stringQ.dequeue());
		assertEquals("carrot", stringQ.dequeue());		
	}

}
import static org.junit.Assert.*;

import java.util.ArrayList;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

public class MyStackTest {
	public MyStack<String> stringS;
	public String a="a", b="b", c="c", d="d", e="e", f="f";
	public ArrayList<String> fill = new ArrayList<String>();
	
	// STUDENT: student tests will use the doubleS
	public MyStack<Double> doubleS;
	// STUDENT: add variables as needed for your student tests
	
	@Before
	public void setUp() throws Exception {
		stringS = new MyStack<String>(5);
		stringS.push(a);
		stringS.push(b);
		stringS.push(c);
		
		//STUDENT: add setup for doubleS for student tests
	}

	@After
	public void tearDown() throws Exception {
		stringS = null;
		doubleS = null;
	}

	@Test
	public void testIsEmpty() throws StackUnderflowException {
		assertEquals(false,stringS.isEmpty());
		stringS.pop();
		stringS.pop();
		stringS.pop();
		assertEquals(true, stringS.isEmpty());
	}

	@Test
	public void testIsFull() throws StackOverflowException {
		assertEquals(false, stringS.isFull());
		stringS.push(d);
		stringS.push(e);
		assertEquals(true, stringS.isFull());
	}

	@Test
	public void testPop() {
		try {
			assertEquals(c, stringS.pop());
			assertEquals(b, stringS.pop());
			assertEquals(a, stringS.pop());
			//Queue is empty, next statement should cause QueueUnderFlowException
			stringS.pop();
			assertTrue("This should have caused an StackUnderflowException", false);
		}
		catch (StackUnderflowException e){
			assertTrue("This should have caused an StackUnderflowException", true);
		}
		catch (Exception e){
			assertTrue("This should have caused an StackUnderflowException", false);
		}
	}

	@Test
	public void testPopStudent() {
		//Use the doubleQ for student tests
		fail("Not yet implemented");
	}
	
	@Test
	public void testTop() throws StackOverflowException, StackUnderflowException {
		assertEquals(c, stringS.top());
		stringS.push(d);
		assertEquals(d, stringS.top());
		stringS.pop();
		stringS.pop();
		assertEquals(b, stringS.top());		
	}

	@Test
	public void testSize() throws StackUnderflowException, StackOverflowException {
		assertEquals(3, stringS.size());
		stringS.push(d);
		assertEquals(4, stringS.size());
		stringS.pop();
		stringS.pop();
		assertEquals(2, stringS.size());
	}

	@Test
	public void testPush() {
		try {
			assertEquals(3, stringS.size());
			assertEquals(true, stringS.push(d));
			assertEquals(4, stringS.size());
			assertEquals(true, stringS.push(e));
			assertEquals(5, stringS.size());
			//Queue is full, next statement should cause QueueOverFlowException
			stringS.push(f);
			assertTrue("This should have caused an StackOverflowException", false);
		}
		catch (StackOverflowException e){
			assertTrue("This should have caused an StackOverflowException", true);
		}
		catch (Exception e){
			assertTrue("This should have caused an StackOverflowException", false);
		}
	}

	@Test
	public void testPushStudent() {
		//Use the doubleQ for student tests
		fail("Not yet implemented");
	}
	
	@Test
	public void testToString() throws StackOverflowException {
		assertEquals("abc", stringS.toString());
		stringS.push(d);
		assertEquals("abcd", stringS.toString());
		stringS.push(e);
		assertEquals("abcde", stringS.toString());
	}

	@Test
	public void testToStringStudent() {
		//Use the doubleQ for student tests
		fail("Not yet implemented");
	}
	
	@Test
	public void testToStringDelimiter() throws StackOverflowException {
		assertEquals("a%b%c", stringS.toString("%"));
		stringS.push(d);
		assertEquals("a&b&c&d", stringS.toString("&"));
		stringS.push(e);
		assertEquals("a/b/c/d/e", stringS.toString("/"));
	}

	@Test
	public void testFill() throws StackUnderflowException {
		fill.add("apple");
		fill.add("banana");
		fill.add("carrot");
		//start with an empty queue
		stringS = new MyStack<String>(5);
		//fill with an ArrayList
		stringS.fill(fill);
		assertEquals(3,stringS.size());
		assertEquals("carrot", stringS.pop());
		assertEquals("banana", stringS.pop());
		assertEquals("apple", stringS.pop());		
	}

}
/* 
* Class: CMSC204 
* Instructor: Robert Alexander
* Description: A program that converts an infix expression to a postfix expression, a postfix to infix and evaluates a postfix expression.
* Due: 9/29/2021
* Platform/compiler: Eclipse
* @author Nicholas Prakoso;
*/

import java.util.ArrayList;
import java.util.Stack;

public class Notation {
	public static double evaluatePostfixExpression(String postfixExpression) throws InvalidNotationFormatException{
		NotationStack<Double> stack = new NotationStack<>(postfixExpression.length());
		char[] s = postfixExpression.toCharArray();
		
		try {
			for (char c : s) {
				if(c == ' ') {
					continue;
				}
				if(Character.isDigit(c) || c == '(') {
					stack.push(Double.parseDouble(Character.toString(c)));
					continue;
				}
				if(c == '*' || c == '+' || c == '-' || c =='/') {
					if(stack.size() < 2) {
						throw new InvalidNotationFormatException();
					}
					double r = stack.pop();
					double l = stack.pop();
					
					switch(c) {
					case '+':
						stack.push(l + r);
						break;
					case '-':
						stack.push(l - r);
						break;
					case '*':
						stack.push(l * r);
						break;
					case '/':
						stack.push(l / r);
						break;
					}
				}
			}
		}
		catch (StackOverflowException | StackUnderflowException ignore) {
			throw new InvalidNotationFormatException();
		}
		if(stack.size() > 1) {
			throw new InvalidNotationFormatException();
		}
		return Double.parseDouble(stack.toString());
	}
	
	public static String convertPostfixToInfix(String postfix) throws InvalidNotationFormatException{
		NotationStack<String> stack = new NotationStack<>(postfix.length());
		
		try {
			for(int i = 0; i < postfix.length(); i++) {
				char c = postfix.charAt(i);
				if(c == ' ') {
					continue;
				}
				if(Character.isDigit(c)) {
					stack.push(Character.toString(c));
					continue;
				}
				if(c == '+' || c == '-' || c == '/' || c == '*') {
					if(stack.size() < 2) {
						throw new InvalidNotationFormatException();
					}
					String one = stack.pop();
					String two = stack.pop();
					String s = "(" + two + c + one + ")";
					stack.push(s);
				}
			}
		}
		catch(StackUnderflowException | StackOverflowException ignore) {
			throw new InvalidNotationFormatException();
		}
		if(stack.size() > 1) {
			throw new InvalidNotationFormatException();
		}
		return stack.toString();
	}
	
	public static String convertInfixToPostfix(String infix) throws InvalidNotationFormatException{
		NotationQueue<Character> queue = new NotationQueue<>(infix.length());
		NotationStack<Character> stack = new NotationStack<>(infix.length());
		char[] s = infix.toCharArray();
		
		try {
			for(char c : s) {
				if(c == ' ') {
					continue;
				}
				if(Character.isDigit(c)) {
					queue.enqueue(c);
					continue;
				}
				if(c == '(') {
					stack.push(c);
				}
				if(c == '+' || c == '-' || c == '/' || c == '*') {
					if(!queue.isEmpty()) {
						char first = stack.first();
						if(first == '+' && c == '+' || first == '-' && c == '-' || first == '/' || first == '*' || c == '-' && first == '+' || c == '+' && first == '-') {
							queue.enqueue(stack.pop());
						}
					}
					stack.push(c);
					continue;
				}
				if(c == ')') {
					while(stack.first() != '(') {
						queue.enqueue(stack.pop());
						if(stack.first() == null) {
							throw new InvalidNotationFormatException();
						}
					}
					stack.pop();
				}
			}
		}
		catch(QueueOverflowException | StackOverflowException | StackUnderflowException ignore) {
			throw new InvalidNotationFormatException();
		}
		return queue.toString();
	}
}

package _solution3;



/**
 * GUI for converting infix to postfix, postfix to infix and evaluating postfix expressions
 * @author Professor Jeannette Kartchner
 */

import java.text.NumberFormat;
import javax.swing.JOptionPane;

import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.control.TitledPane;
import javafx.scene.control.ToggleGroup;
import javafx.scene.Scene;
import javafx.scene.control.Alert;
import javafx.scene.control.Alert.AlertType;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.RadioButton;
import javafx.stage.Stage;
import javafx.scene.control.TextField;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
 
public class NotationGui extends Application {

	private TextField infixtxt, infixtxt2, postfixtxt, postfixtxt2;
	private Label infixlbl, infixlbl2,postfixlbl, postfixlbl2,evalanswerlbl, evalanswer;
	private RadioButton infixToPostfix, postfixToInfix;
	private ToggleGroup myToggleGroup;
	private NumberFormat numFormat = NumberFormat.getNumberInstance();
	private Button conversionBtn, evaluatePostBtn, evaluateInBtn, exitBtn;
	private Alert alert = new Alert(AlertType.INFORMATION);
	 
	
	// Handler class.
	private class ButtonEventHandler implements EventHandler<ActionEvent> {
		@Override
		public void handle(ActionEvent e) {
			String infix,postfix,result;
			//For conversion button
			if (e.getSource() == conversionBtn) {
				//if infix to postfix is selected
				try{
					if(infixToPostfix.isSelected())
					{
						infix = infixtxt.getText();
						result = Notation.convertInfixToPostfix(infix);
						postfixlbl.setVisible(true);
						postfixtxt.setVisible(true);
						postfixtxt.setText(result);

					}
					//if postfix to infix is selected
					else if(postfixToInfix.isSelected())
					{
						postfix = postfixtxt.getText();
						result = Notation.convertPostfixToInfix(postfix);
						System.out.println("result "+result);
						infixlbl.setVisible(true);
						infixtxt.setVisible(true);
						infixtxt.setText(result);
					}

				}
				catch (InvalidNotationFormatException exception)
				{
					JOptionPane.showMessageDialog(null, exception.getMessage());
				}

			} 
			//For evaluate Post button
			else if (e.getSource() == evaluatePostBtn) {

				try{
					infixtxt2.setText("");
					String postfixExpr = postfixtxt2.getText();
					double a = Notation.evaluatePostfixExpression(postfixExpr);
					evalanswerlbl.setVisible(true);
					evalanswer.setVisible(true);
					evalanswer.setText(Double.toString(Notation.evaluatePostfixExpression(postfixExpr)));
				}
				catch (InvalidNotationFormatException exception)
				{
					JOptionPane.showMessageDialog(null, exception.getMessage());
				}

			} 
			//For evaluate In button
			else if (e.getSource() == evaluateInBtn) {

				try{
					postfixtxt2.setText("");
					String infixExpr = infixtxt2.getText();
					double a = Notation.evaluateInfixExpression(infixExpr);
					evalanswerlbl.setVisible(true);
					evalanswer.setVisible(true);
					evalanswer.setText(Double.toString(Notation.evaluateInfixExpression(infixExpr)));
				}
				catch (InvalidNotationFormatException exception)
				{
					JOptionPane.showMessageDialog(null, exception.getMessage());
				}

			} 
			//For exit button
			else if (e.getSource() == exitBtn){

				System.exit(0);
			} 
			//For radio buttons, display appropriate textfields
			else {
				if (infixToPostfix.isSelected()){
					postfixtxt.setVisible(false);
					postfixlbl.setVisible(false);
					infixtxt.setText("");
					conversionBtn.setDisable(false);
				} if (!infixToPostfix.isSelected()){
					postfixtxt.setVisible(true);
					postfixlbl.setVisible(true);
				} if (postfixToInfix.isSelected()){
					infixtxt.setVisible(false);
					infixlbl.setVisible(false);
					postfixtxt.setText("");
					conversionBtn.setDisable(false);
				} if (!postfixToInfix.isSelected()){
					infixtxt.setVisible(true);
					infixlbl.setVisible(true);
				}
			}
		}
	}

	@Override
	public void start(Stage stage) {
		
		alert.setTitle("Notatation Utility");
		alert.setHeaderText(null);
		// Create notation labels
		infixlbl = new Label("Infix Expression: ");
		infixlbl2 = new Label("Infix Expression: ");
		postfixlbl = new Label("Postfix Expression:");
		postfixlbl2 = new Label("Postfix Expression:");

		// create notation text fields
		infixtxt = new TextField();
		infixtxt.setMaxWidth(150);
		infixtxt2 = new TextField();
		infixtxt2.setMaxWidth(150);
		postfixtxt = new TextField();
		postfixtxt.setMaxWidth(150);
		postfixtxt2 = new TextField();
		postfixtxt2.setMaxWidth(150);
		
		//create radio buttons
		myToggleGroup = new ToggleGroup();
		infixToPostfix = new RadioButton("Infix to Postfix");
		postfixToInfix = new RadioButton("Postfix to Infix");
		infixToPostfix.setToggleGroup(myToggleGroup);
		postfixToInfix.setToggleGroup(myToggleGroup);
		infixToPostfix.setOnAction(new ButtonEventHandler());
		postfixToInfix.setOnAction(new ButtonEventHandler());

		VBox radioPane1 = new VBox(20);
		radioPane1.getChildren().addAll(infixToPostfix,postfixToInfix);
		
		VBox infixPane1 = new VBox(20);
		infixPane1.getChildren().addAll(infixlbl,infixtxt);
		
		VBox postfixPane1 = new VBox(20);
		postfixPane1.getChildren().addAll(postfixlbl,postfixtxt);
		
		HBox conversionPane1 = new HBox(20);
		conversionPane1.getChildren().addAll(radioPane1,infixPane1,postfixPane1);

		// Create buttons
		conversionBtn = new Button("Convert");
		conversionBtn.setDisable(true);
		evaluatePostBtn = new Button("Evaluate Postfix");
		evaluateInBtn = new Button("Evaluate Infix");
		exitBtn = new Button("Exit");

		conversionBtn.setOnAction(new ButtonEventHandler());
		evaluatePostBtn.setOnAction(new ButtonEventHandler());
		evaluateInBtn.setOnAction(new ButtonEventHandler());
		exitBtn.setOnAction(new ButtonEventHandler());
		
		HBox buttonPane1 = new HBox(20);
		buttonPane1.getChildren().addAll(exitBtn);
		buttonPane1.setPadding(new Insets(20, 10, 5, 10));
		buttonPane1.setAlignment(Pos.CENTER);

		// Main Pane
		VBox mainPane = new VBox();

		// Notation Conversion pane
		VBox conversionPane = new VBox();

		// Add convert button convertionPanel info to the conversionPane
		conversionPane.getChildren().addAll(conversionPane1, conversionBtn);

		TitledPane convertTitlePane = new TitledPane("Notation Conversion",
				conversionPane);
		convertTitlePane.setCollapsible(false);
		convertTitlePane.setMaxWidth(550);
		convertTitlePane.setPadding(new Insets(20, 10, 5, 10));
		
		//Postfix label and textfield
		VBox postfixPane2 = new VBox(20);
		postfixPane2.getChildren().addAll(postfixlbl2,postfixtxt2, evaluatePostBtn);
		postfixPane2.setPadding(new Insets(20, 10, 5, 10));
		
		//Postfix label and textfield
		VBox infixPane2 = new VBox(20);
		infixPane2.getChildren().addAll(infixlbl2,infixtxt2, evaluateInBtn);
		infixPane2.setPadding(new Insets(20, 10, 5, 10));
		
		evalanswerlbl = new Label("Answer: ");
		evalanswerlbl.setVisible(false);
		evalanswer = new Label();
		evalanswer.setVisible(false);
		
		VBox evalanswerPane = new VBox();
		evalanswerPane.getChildren().addAll(evalanswerlbl, evalanswer);
		//HBox evalbuttonPostPane = new HBox();
		//evalbuttonPostPane.getChildren().addAll(evaluatePostBtn);
		//evalbuttonPostPane.setPadding(new Insets(20, 10, 5, 10));
		
		//HBox evalbuttonInPane = new HBox();
		//evalbuttonInPane.getChildren().addAll(evaluatePostBtn);
		//evalbuttonInPane.setPadding(new Insets(20, 10, 5, 10));
	
		
		//Notation Evaluation pane
		HBox evaluationPane = new HBox();
		evaluationPane.getChildren().addAll(postfixPane2, infixPane2, evalanswerPane);
		
		TitledPane evalTitlePane = new TitledPane("Notation Evaluation",
				evaluationPane);
		evalTitlePane.setCollapsible(false);
		evalTitlePane.setMaxWidth(550);
		evalTitlePane.setPadding(new Insets(20, 10, 5, 10));


		mainPane.getChildren().addAll(convertTitlePane, evalTitlePane,
				buttonPane1);
		Scene scene = new Scene(mainPane, 550, 430);
		stage.setScene(scene);

		// Set stage title and show the stage.
		stage.setTitle("Notation Utility ");
		stage.show();
	}

	public static void main(String[] args) {
		launch(args);
	}
}

import java.util.ArrayList;
import java.util.Stack;

public class NotationQueue<T> implements QueueInterface<T> {
	private ArrayList<T> queue;
	private int cap;
	
	NotationQueue(){
		queue = new ArrayList<>(cap);
	}
	
	public boolean isEmpty() {
		if(queue.size() == cap) {
			return true;
		} else {
			return false;
		}
	}
	
	public int size() {
		return queue.size();
	}
	
	public boolean isFull() {
		if(queue.size() == cap) {
			return true;
		} else {
			return false;
		}
	}
	
	public T dequeue() throws QueueUnderflowException{
		if(isEmpty()) {
			throw new QueueUnderflowException();
		} else {
		return queue.size();
		}
	}
	
	public boolean enqueue(T e) throws QueueOverflowException{
		if(queue.size() == cap) {
			throw new QueueOverflowException();
		} else {
			queue.add(e);
			return true;
		}
	}
	
	public String toString() {
		String s = " ";
		for(T item: queue) {
			s += item.toString();
		}
		return s;
	}
	
	public String toString(String delimiter) {
		String s = " ";
		for(T item: queue) {
			s += item.toString();
			s += delimiter;
		}
		s = s.substring(0, s.length() - 1);
		return s;
	}
	
	public void fill(ArrayList<T> list) {
		queue.clear();
		for(T item: list) {
			queue.add(item);
		}
	}
	
}

import static org.junit.Assert.*;

import java.util.ArrayList;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

public class NotationQueueTest {
	public NotationQueue<String> stringQ;
	public String a="a", b="b", c="c", d="d", e="e", f="f";
	public ArrayList<String> fill = new ArrayList<String>();
	
	// STUDENT: student tests will use the doubleQ
	public NotationQueue<Double> doubleQ;
	// STUDENT: add variables as needed for your student tests

	@Before
	public void setUp() throws Exception {
		stringQ = new NotationQueue<String>(5);
		stringQ.enqueue(a);
		stringQ.enqueue(b);
		stringQ.enqueue(c);
		
		//STUDENT: add setup for doubleQ for student tests
	}

	@After
	public void tearDown() throws Exception {
		stringQ = null;
		doubleQ = null;
	}

	@Test
	public void testIsEmpty() throws QueueUnderflowException {
		assertEquals(false,stringQ.isEmpty());
		stringQ.dequeue();
		stringQ.dequeue();
		stringQ.dequeue();
		assertEquals(true, stringQ.isEmpty());
	}

	@Test
	public void testDequeue() {
		try {
			assertEquals(a, stringQ.dequeue());
			assertEquals(b, stringQ.dequeue());
			assertEquals(c, stringQ.dequeue());
			//Queue is empty, next statement should cause QueueUnderFlowException
			stringQ.dequeue();
			assertTrue("This should have caused an QueueUnderflowException", false);
		}
		catch (QueueUnderflowException e){
			assertTrue("This should have caused an QueueUnderflowException", true);
		}
		catch (Exception e){
			assertTrue("This should have caused an QueueUnderflowException", false);
		}
	}
	
	@Test
	public void testDequeueStudent() {
		//Use the doubleQ for student tests
		fail("Not yet implemented");
	}

	@Test
	public void testSize() throws QueueUnderflowException, QueueOverflowException {
		assertEquals(3, stringQ.size());
		stringQ.enqueue(d);
		assertEquals(4, stringQ.size());
		stringQ.dequeue();
		stringQ.dequeue();
		assertEquals(2, stringQ.size());
	}

	@Test
	public void testEnqueue() {
		try {
			assertEquals(3, stringQ.size());
			assertEquals(true, stringQ.enqueue(d));
			assertEquals(4, stringQ.size());
			assertEquals(true, stringQ.enqueue(e));
			assertEquals(5, stringQ.size());
			//Queue is full, next statement should cause QueueOverFlowException
			stringQ.enqueue(f);
			assertTrue("This should have caused an QueueOverflowException", false);
		}
		catch (QueueOverflowException e){
			assertTrue("This should have caused an QueueOverflowException", true);
		}
		catch (Exception e){
			assertTrue("This should have caused an QueueOverflowException", false);
		}
	}

	@Test
	public void testEnqueueStudent() {
		//Use the doubleQ for student tests
		fail("Not yet implemented");
	}

	@Test
	public void testIsFull() throws QueueOverflowException {
		assertEquals(false, stringQ.isFull());
		stringQ.enqueue(d);
		stringQ.enqueue(e);
		assertEquals(true, stringQ.isFull());
	}

	@Test
	public void testToString() throws QueueOverflowException {
		assertEquals("abc", stringQ.toString());
		stringQ.enqueue(d);
		assertEquals("abcd", stringQ.toString());
		stringQ.enqueue(e);
		assertEquals("abcde", stringQ.toString());
	}
	
	@Test
	public void testToStringStudent() {
		//Use the doubleQ for student tests
		fail("Not yet implemented");
	}

	@Test
	public void testToStringDelimiter() throws QueueOverflowException {
		assertEquals("a%b%c", stringQ.toString("%"));
		stringQ.enqueue(d);
		assertEquals("a&b&c&d", stringQ.toString("&"));
		stringQ.enqueue(e);
		assertEquals("a/b/c/d/e", stringQ.toString("/"));
	}

	@Test
	public void testFill() throws QueueUnderflowException {
		fill.add("apple");
		fill.add("banana");
		fill.add("carrot");
		//start with an empty queue
		stringQ = new NotationQueue<String>(5);
		//fill with an ArrayList
		stringQ.fill(fill);
		assertEquals(3,stringQ.size());
		assertEquals("apple", stringQ.dequeue());
		assertEquals("banana", stringQ.dequeue());
		assertEquals("carrot", stringQ.dequeue());		
	}

}
